package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/gorilla/mux"
	"github.com/gorilla/websocket"
	"github.com/mailru/easygo/netpoll"
)

var ctx = context.Background()

// Generated by https://quicktype.io

type Inmsg struct {
	Key string `json:"key"`
	Msg string `json:"msg"`
}

// May have some buffer inside or drop message if it likes
type Notifier[T any] interface {
	AddMessage(T) error
	AddNotifierchan(chan (T)) error
	GetNotifierchan() chan (T)

	// This function is concurrently and blokingly called
	AddNotifierfunc(func(T)) error
	DeleteNotifier()
}

type NoBufferNotifier[T any] struct {
	notifierchan chan (T)
	notifierfunc func(T)
}

func (n *NoBufferNotifier[T]) AddMessage(msg T) error {
	if n.notifierchan != nil {
		n.notifierchan <- msg
		return nil
	} else if n.notifierfunc != nil {
		n.notifierfunc(msg)
		return nil
	}
	return errors.New("notifier not found")
}

func (n *NoBufferNotifier[T]) AddNotifierchan(ch chan (T)) error {
	if n.notifierchan == nil && n.notifierfunc == nil {
		n.notifierchan = ch
		return nil
	} else {
		return errors.New("notifier already exists")
	}
}

func (n *NoBufferNotifier[T]) GetNotifierchan() chan (T) {
	return n.notifierchan
}

func (n *NoBufferNotifier[T]) AddNotifierfunc(f func(T)) error {
	if n.notifierchan == nil && n.notifierfunc == nil {
		n.notifierfunc = f
		return nil
	}
	return errors.New("notifier already exists")
}

func (n *NoBufferNotifier[any]) DeleteNotifier() {
	n.notifierchan = nil
	n.notifierfunc = nil
}

func main() {
	// nbn := NoBufferNotifier[redis.Message]{}
	rwm := struct {
		kv   map[string]chan (redis.Message)
		lock sync.RWMutex
	}{}
	rdb := redis.NewClient(&redis.Options{
		Addr:     "127.0.0.1:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})

	upy := websocket.Upgrader{
		WriteBufferPool: &sync.Pool{},
	}
	epool, err := netpoll.New(&netpoll.Config{})
	if err != nil {
		log.Fatal(err)
	}
	mainrout := mux.NewRouter()

	mainrout.HandleFunc("/{key}", func(w http.ResponseWriter, r *http.Request) {

		vars := mux.Vars(r)
		key, ok := vars["key"]
		if ok != true {
			w.Write([]byte("key not found"))
		}

		conn, err := upy.Upgrade(w, r, nil)
		if err != nil {
			log.Println(err)
		}
		defer conn.Close()
		rwm.lock.Lock()

		if rwm.kv[key] == nil {
			rwm.kv[key] = make(chan redis.Message)
		}
		rwm.lock.Unlock()
		select {
		case msg := <-rwm.kv[key]:
			conn.WriteMessage(websocket.TextMessage, []byte(msg.Payload))
		default:

			conn.SetReadDeadline(time.Now().Add(time.Microsecond * 20))
			_, msg, err := conn.ReadMessage()
			if err != nil {
				log.Println(err)
				return
			}
			rawconn, err := netpoll.Handle(conn.UnderlyingConn(), netpoll.EventRead)
			if err != nil {
				log.Println(err)
				return
			}

			netpoll.Poller.Start(rawconn, func(e netpoll.Event) {
				go func() {
					_, buf, _ := conn.ReadMessage()
					fmt.Print("event: ", buf)
				}()
			})

		}
	})
}
